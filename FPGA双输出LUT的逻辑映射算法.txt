   2025 ä¸­å›½ç ”ç©¶ç”Ÿåˆ›â€œèŠ¯â€å¤§èµ›Â·EDA ç²¾è‹±æŒ‘æˆ˜èµ›


ä¸€ã€èµ›é¢˜åç§°
FPGA åŒè¾“å‡º LUT çš„é€»è¾‘æ˜ å°„ç®—æ³•

äºŒã€å‘½é¢˜å•ä½
æ·±åœ³å¸‚ç´«å…‰åŒåˆ›ç”µå­è‚¡ä»½æœ‰é™å…¬å¸

ä¸‰ã€èµ›é¢˜èƒŒæ™¯

   å½“å‰å…ˆè¿›çš„ FPGAï¼ˆField Programmable Gate Arrayï¼ŒçŽ°åœºå¯ç¼–ç¨‹é€»è¾‘é—¨é˜µåˆ—ï¼‰æž¶

æž„ä¸­é€šå¸¸ä½¿ç”¨åŒè¾“å‡ºç«¯å£çš„ LUT(Look-Up-Tableï¼ŒæŸ¥æ‰¾è¡¨)ç»“æž„ï¼ˆä»¥ä¸‹ç®€ç§°â€œåŒè¾“å‡º

LUTâ€ï¼‰ï¼Œè€Œä¼ ç»Ÿçš„ LUT æ˜ å°„ç®—æ³•åªèƒ½å°†ç»„åˆé€»è¾‘é—¨æ˜ å°„åˆ°å•è¾“å‡ºç«¯å£çš„ LUTï¼Œç»™

FPGA çš„ç»¼åˆå·¥å…·å¸¦æ¥ä¸€ä¸ªæ–°çš„æŒ‘æˆ˜â€”â€”å¦‚ä½•æ‰èƒ½æ›´å¥½çš„å°†ç»„åˆé€»è¾‘æ˜ å°„åˆ°åŒè¾“å‡º

LUT ä¸Šã€‚åŒè¾“å‡º LUT çš„ä¸¤ä¸ªè¾“å‡ºç«¯å£å…±ç”¨éƒ¨åˆ†è¾“å…¥ï¼Œä¸”ä¸¤ä¸ªè¾“å‡ºä¹‹é—´éœ€è¦æ»¡è¶³ä¸€å®š

çš„é€»è¾‘å…³ç³»ï¼Œéš¾ç‚¹åœ¨äºŽæ˜ å°„è¿‡ç¨‹ä¸­å¦‚ä½•åˆ©ç”¨åŒè¾“å‡º LUT çš„ç»“æž„å¹¶åœ¨ä»£ä»·å‡½æ•°ä¸­ä½“çŽ°

åŒè¾“å‡º LUT å¸¦æ¥çš„å½±å“ï¼Œä»¥åŠåœ¨æ˜ å°„ç»“æŸåŽå¦‚ä½•æ‹¼æŽ¥ LUT æ¥æœ€å°åŒ–ç½‘è¡¨çš„æ€»é¢ç§¯ã€‚

   FPGA è®¾è®¡æµç¨‹å¦‚å›¾ 1 æ‰€ç¤ºã€‚æœ¬èµ›é¢˜å±žäºŽ EDAï¼ˆElectronic design automationï¼Œç”µ

å­è®¾è®¡è‡ªåŠ¨åŒ–ï¼‰æŠ€æœ¯ä¸­çš„ FPGA é€»è¾‘ç»¼åˆèŒƒç•´ã€‚æœ¬é¢˜åˆ†åŸºç¡€é¢˜ç›®å’Œè¿›é˜¶é¢˜ç›®ä¸¤ä¸ªéƒ¨åˆ†ã€‚

åŸºç¡€é¢˜ç›®ä¸ºç»™å®šå·²ç»æ˜ å°„å¥½çš„å•ç«¯å£ LUT ç½‘è¡¨ï¼Œæ‰¾åˆ°ä¸€ä¸ªç®—æ³•å°†ä¸¤ä¸ª LUT ç»„åˆæˆä¸€

ä¸ªåŒè¾“å‡ºçš„ LUTï¼Œä½¿å¾—ç½‘è¡¨é‡Œæœ€ç»ˆçš„ LUT æ•°é‡å°½å¯èƒ½å°‘ï¼›è¿›é˜¶é¢˜ç›®ä¸ºå¦‚ä½•ä¿®æ”¹ä¼ ç»Ÿ

çš„å•ç«¯å£ LUT æ˜ å°„ç®—æ³•ï¼Œç›´æŽ¥æ˜ å°„åˆ°åŒè¾“å‡º LUTï¼Œå®žçŽ°æœ€å°‘çš„ LUT çš„æ•°é‡ã€‚ä¸¤ä¸ªå­

é¢˜ç›®åˆ†åˆ«å±žäºŽé€»è¾‘ç»¼åˆçš„ Technology-dependent Optimizationï¼ˆå·¥è‰ºç›¸å…³çš„ä¼˜åŒ–ï¼ŒæŒ‡åˆ©

ç”¨ç‰¹å®šå·¥è‰ºåº“å¯¹ç½‘è¡¨è¿›è¡Œä¼˜åŒ–ï¼‰å’Œ Technology Mapï¼ˆå·¥è‰ºæ˜ å°„ï¼ŒæŒ‡å°†é€šç”¨çš„ç”µè·¯å•å…ƒ

æ˜ å°„åˆ°ç‰¹å®šçš„å·¥è‰ºåº“ä¸­çš„å•å…ƒï¼‰ä¸¤ä¸ªéƒ¨åˆ†ã€‚



                             1
                  å›¾ 1 FPGA çš„ EDA è®¾è®¡æµç¨‹

å››ã€ç¤ºä¾‹æµç¨‹
  ç´«å…‰åŒåˆ›æä¾›äº†ä¸€ä»½åŸºç¡€ä»£ç ã€‚åŸºç¡€ä»£ç æ˜¯åŸºäºŽå¼€æºé¡¹ç›® yosys æ‰€ç¼–å†™, ç”¨äºŽä¸­

å›½ç ”ç©¶ç”Ÿåˆ›â€œèŠ¯â€å¤§èµ›-EDA ç²¾è‹±æŒ‘æˆ˜èµ›ã€‚å‚èµ›è€…å¯ä»¥åœ¨è¿™ä»½ä»£ç åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹ã€‚

å›¾ 2 ç»™å‡ºäº†ä½¿ç”¨è¿™ä»½ä»£ç çš„ç¤ºä¾‹æµç¨‹ã€‚

  ç´«å…‰åŒåˆ›æä¾›çš„ä»£ç ã€è„šæœ¬ã€æµ‹è¯•ç”¨ä¾‹ç­‰å­˜æ”¾äºŽyosys/techlibs/pangoã€‚æºä»£ç æ–‡

ä»¶synth_pango. ccä¸­ä¾æ®å‚è€ƒæ–‡çŒ®[1]å®žçŽ°äº†ä¸€ä¸ªç®€å•çš„æ˜ å°„ç®—æ³•ï¼ŒåŠŸèƒ½æ˜¯å°†ç½‘è¡¨ä¸­çš„

ç»„åˆé€»è¾‘é—¨æ˜ å°„åˆ°ç´«å…‰åŒåˆ›çš„ LUT åŽŸè¯­ï¼Œå¯¹æ–‡çŒ®ä¸­æœªæåŠçš„ç»†èŠ‚åšäº†éƒ¨åˆ†çŒœæƒ³å’Œç®€

åŒ–ï¼Œå¯ä»¥åœ¨ yosys å·¥å…·ä¸‹ä½¿ç”¨ synth_pango å‘½ä»¤æ¥ä½¿ç”¨è¯¥åŠŸèƒ½ã€‚score. ccä»£ç çš„åŠŸèƒ½æ˜¯

è®¡ç®—æ˜ å°„åŽç½‘è¡¨çš„ä»£ä»·å‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨ score å‘½ä»¤æ¥ä½¿ç”¨è¯¥åŠŸèƒ½ã€‚




                           2
                           å›¾ 2 ç¤ºä¾‹æµç¨‹å›¾

   Yosysé¡¹ç›®ä¸­åŒ…å«ä¸¤ä¸ªéžå¸¸å…³é”®çš„æ•°æ®ç»“æž„ï¼ŒSigBitå’ŒCellã€‚

   SigBitåœ¨ yosys ä¸­è¡¨ç¤º wire çš„å…¶ä¸­ä¸€ä¸ªæ¯”ç‰¹ï¼Œåœ¨é€»è¾‘ç»¼åˆè¿‡ç¨‹ä¸­ä¸å…³æ³¨ wire çš„ä½

å®½å’Œ wire ä¹‹é—´çš„ assign å…³ç³»ï¼Œæ‰€ä»¥å°†äº’ç›¸è¿žæŽ¥çš„ wire è½¬ä¸ºå”¯ä¸€çš„SigBitè¡¨ç¤ºã€‚ä»£ç ä¸­

ä½¿ç”¨SigBitå¯¹è±¡èŽ·å–å…¶ driverï¼Œreaderï¼Œdepth ç­‰æ•°æ®ã€‚

   Cellè¡¨ç¤ºç½‘è¡¨ä¸­çš„æŸä¸ªå®žä¾‹åŒ–å¯¹è±¡ï¼Œç»¼åˆè¿‡ç¨‹ä¸­ä»…å…³æ³¨ç»„åˆé€»è¾‘é—¨çš„ cellï¼Œç´«å…‰åŒ

åˆ›æä¾›çš„ç”¨ä¾‹ä»…åŒ…å«ä¸Žé—¨ã€æˆ–é—¨ã€å¼‚æˆ–é—¨ã€é€‰æ‹©å™¨ã€åç›¸å™¨ç±»åž‹çš„ç»„åˆé€»è¾‘é—¨ï¼Œå¯¹äºŽ

å…¶ä»–ç±»åž‹çš„ cell å¯ä»¥ä¸åšä»»ä½•å¤„ç†ï¼ŒåŽŸå°ä¸åŠ¨çš„è¾“å‡ºã€‚

äº”ã€åŒè¾“å‡º LUT æž¶æž„ä»‹ç»
   GTP_ å¼€ å¤´ çš„ cell ç±» åž‹ æ˜¯ ç´« å…‰ åŒ åˆ› çš„ FPGA åŽŸ è¯­ ï¼Œ yosys/techlibs/pango/

pango_sim. væ–‡ä»¶ä¸­åŒ…å«äº†éƒ¨åˆ†åŽŸè¯­çš„ä»¿çœŸæ¨¡åž‹ã€‚

   GTP_LUT1~GTP_LUT6 æ˜¯ n è¾“å…¥ 1 è¾“å‡ºçš„æŸ¥æ‰¾è¡¨ã€‚

   GTP_LUT6D æ˜¯ 6 è¾“å…¥ 2 è¾“å‡ºçš„æŸ¥æ‰¾è¡¨ï¼Œå…¶ä»¿çœŸæ¨¡åž‹å¦‚å›¾ 3ï¼Œå†…éƒ¨ç»“æž„å¦‚å›¾ 4ã€‚

   åœ¨èµ„æºå ç”¨çš„ä¼°ç®—ä¸­ï¼ŒGTP_LUT6D å’Œ GTP_LUT æ˜¯ç›¸ç­‰çš„ï¼Œéƒ½ä¼šå ç”¨ FPGA èŠ¯

ç‰‡ä¸­çš„ä¸€ä¸ªæŸ¥æ‰¾è¡¨ç¡¬ä»¶èµ„æºï¼Œä½†æ˜¯ GTP_LUT6D é™¤äº†èƒ½å¤Ÿå®žçŽ° GTP_LUT6 çš„åŠŸèƒ½å¤–ï¼Œ

è¿˜èƒ½å¤Ÿé¢å¤–å®žçŽ° 1 ä¸ª 5 è¾“å…¥ 1 è¾“å‡ºçš„æŸ¥æ‰¾è¡¨ï¼ŒZ5 çš„é€»è¾‘è¡¨è¾¾å¼æ˜¯ Z é€»è¾‘è¡¨è¾¾å¼çš„å­

å¼ï¼Œä¸¤ä¸ªé€»è¾‘è¡¨è¾¾å¼çš„ I[4:0]æ˜¯ç›¸åŒçš„ã€‚åˆ©ç”¨è¿™ä¸ªç‰¹ç‚¹å¯ä»¥å°†è¾“å…¥ç›¸åŒæˆ–ç›¸ä¼¼çš„ä¸¤ä¸ª



                                3
é€»è¾‘è¡¨è¾¾å¼æ‹¼æŽ¥åˆ°ä¸€èµ·ä½¿ç”¨ä¸€ä¸ª GTP_LUT6D æ¥è¾“å‡ºä¸¤ä¸ªä¿¡å·ï¼Œè¾¾åˆ°èŠ‚çœé¢ç§¯çš„ç›®çš„ã€‚

 // GTP_LUT6D ä»¿çœŸæ¨¡åž‹
 module GTP_LUT6D
 #(
      parameter [63:0] INIT = 64'h0000_0000_0000_0000
 )(
      output Z,
      output Z5,
      input I0,
      input I1,
      input I2,
      input I3,
      input I4,
      input I5
 );
 wire z5a,z5b;
 $lut #(.WIDTH(5),.LUT(INIT[31:0])) luta_cell(.A({I4,I3,I2,I1,I0}),.Y(z5a));
 $lut #(.WIDTH(5),.LUT(INIT[63:32])) lutb_cell(.A({I4,I3,I2,I1,I0}),.Y(z5b));
 $mux #(.WIDTH(1)) u1(.A(z5a),.B(z5b),.S(I5),.Y(Z));
 assign Z5 = z5a;
 endmodule



                                    å›¾ 3 GTP_LUT6D ä»¿çœŸæ¨¡åž‹




                                  å›¾ 4 GTP_LUT6D å†…éƒ¨ç»“æž„å›¾




                                                  4
å…­ã€ç«žèµ›å†…å®¹

  ç«žèµ›å†…å®¹åŒ…å«ä¸¤ä¸ªæ–¹é¢ï¼š

  ï¼ˆ1ï¼‰åŸºç¡€é¢˜

  ç»™å®šå·²ç»æ˜ å°„å¥½çš„å•ç«¯å£ GTP_LUT ç½‘è¡¨ï¼Œè®¾è®¡ç®—æ³•å’ŒåŠŸèƒ½å°†ç½‘è¡¨ä¸­çš„ GTP_LUT

æ‹¼æŽ¥æˆä¸º GTP_LUT6Dï¼Œå°½å¯èƒ½å‡å°‘æ€» LUT æ•°é‡ï¼Œå³ GTP_LUT å’Œ GTP_LUT6D çš„æ€»

æ•°ã€‚

  ä¾‹å¦‚ï¼Œç½‘è¡¨ä¸­å¦‚æžœå­˜åœ¨ä¸¤ä¸ª GTP_LUT çš„é€»è¾‘åˆ†åˆ«æ˜¯O1 = A&B&D&E; O2 =

A&B&C&F | A&B&D&Eï¼Œåˆ™å¯ä»¥å°†è¿™ä¸¤ä¸ª GTP_LUT æ‹¼æŽ¥æˆä¸ºä¸€ä¸ª GTP_LUT6Dï¼Œæ‹¼æŽ¥

åŽç½‘è¡¨çš„æ€» LUT æ•°é‡å‡å°‘ 1ã€‚




                    å›¾ 5 æ‹¼æŽ¥ LUT ä¸¾ä¾‹è¯´æ˜Ž

  ï¼ˆ2ï¼‰è¿›é˜¶é¢˜

  åœ¨ LUT æ˜ å°„ç®—æ³•å±‚é¢æ”¯æŒç›´æŽ¥æ˜ å°„åˆ° GTP_LUT6Dã€‚å‚èµ›è€…å¯ä»¥ä¿®æ”¹æˆ–é‡æ–°è®¾è®¡

æ˜ å°„ç®—æ³•ï¼Œå®žçŽ°ç›´æŽ¥æ˜ å°„å‡º GTP_LUT6Dï¼Œä½¿ç”¨æœ€å°‘çš„ LUT æ€»æ•°ã€‚

  å‚èµ›è€…å¿…éœ€æäº¤ç¨‹åºå¯æ‰§è¡Œæ–‡ä»¶ï¼Œä»¥åŠå¿…è¦çš„æ–‡æ¡£è¯´æ˜Žã€‚ä¸ºé¿å…ç¨‹åºä¾èµ–ç‰¹å®šçš„

åº“å¯¼è‡´çš„ä¸èƒ½æ­£å¸¸è¿è¡Œï¼Œå»ºè®®æäº¤æºä»£ç ã€‚




                           5
ä¸ƒã€ç”¨ä¾‹
  ç´«å…‰åŒåˆ›ä¼šæä¾›è‡³å°‘ 6 ä¸ªæµ‹è¯•ç”¨ä¾‹å’Œè‡³å°‘ 10 ä¸ªè¯„åˆ†ç”¨ä¾‹ã€‚èµ›å‰ä¼šå…¬å¸ƒæµ‹è¯•ç”¨ä¾‹ï¼Œ

è€Œè¯„åˆ†ç”¨ä¾‹ä¸ä¼šåœ¨æ¯”èµ›ç»“æŸå‰å…¬å¼€ã€‚ç”¨ä¾‹ä¹‹é—´çš„è§„æ¨¡å­˜åœ¨å·®å¼‚ï¼Œæ²¡æœ‰éš¾æ˜“åŒºåˆ†ã€‚

  åŸºç¡€é¢˜å’Œè¿›é˜¶é¢˜çš„ç”¨ä¾‹æ˜¯ç›¸åŒçš„ï¼Œä¸åšåŒºåˆ†ã€‚è‹¥å‚èµ›è€…é€‰æ‹©åªè§£å†³åŸºç¡€é¢˜ï¼Œä¹Ÿå¿…

é¡»å°†ç»„åˆé€»è¾‘é—¨æ˜ å°„ä¸º GTP_LUTï¼Œå¯ä»¥ä½¿ç”¨åŸºç¡€ä»£ç ä¸­çš„ synth_pango åŠŸèƒ½æˆ–å…¶ä»–ã€‚

  è¿™äº›ç”¨ä¾‹ä¸­çš„éžç»„åˆé€»è¾‘éƒ¨åˆ†å·²ç»è¢«æ˜ å°„åˆ°ç´«å…‰åŒåˆ› FPGA çš„ GTP ç±»åž‹ï¼Œå‚èµ›

è€…éœ€è¦å¤„ç†ä½™ä¸‹çš„ç»„åˆé€»è¾‘é—¨ï¼Œå›¾ 6 ç»™å‡ºäº†éœ€è¦å¤„ç†çš„äº”ç§ç»„åˆé€»è¾‘é—¨çš„ç¤ºä¾‹ã€‚

  æ‰€æœ‰ç”¨ä¾‹å‡æœ‰å¦‚ä¸‹ç‰¹å¾ï¼š

  ï¼ˆ1ï¼‰Verilog æ ¼å¼çš„ç»“æž„åŒ–ç½‘è¡¨, ä¸å«è¿‡ç¨‹å—æˆ–é«˜çº§è¿ç®—ç¬¦ï¼›

  ï¼ˆ2ï¼‰åªåŒ…å«ä¸€ä¸ªå±•å¹³çš„ moduleï¼ŒåŒ…å«çš„ cell å‡ä¸º yosys å†…ç½®ç±»åž‹æˆ– GTP ç±»åž‹ï¼›

  ï¼ˆ3ï¼‰éžç»„åˆé€»è¾‘é—¨çš„ cellï¼ˆå¯„å­˜å™¨ï¼ŒRAMï¼ŒIO ç­‰ï¼‰è§†ä¸º black boxï¼Œå‚èµ›è€…ä¸èƒ½

å¯¹å…¶åšä»»ä½•ä¿®æ”¹ï¼›

  ï¼ˆ4ï¼‰ç»„åˆé€»è¾‘é—¨ç±»åž‹å‡ä¸º yosys å†…ç½®çš„é€»è¾‘é—¨ç±»åž‹ï¼Œä¸”åªå­˜åœ¨å›¾ 6 ä¸­çš„äº”ç§ç±»åž‹ï¼Œ

$_AND_ã€ $_OR_ã€ $_XOR_å‡ä¸º 2 è¾“å…¥é€»è¾‘é—¨ï¼Œ$_MUX_å’Œ$_NOT_çš„ä½å®½ä¸º 1ã€‚

  \$_OR_    u1 (.A(nt_rst), .B(N145 ), .Y(N145_1 ));
  \$_AND_ u2 (.A(N6_inv), .B(N167_4 ), .Y(N107 ));
  \$_NOT_ u3 (.A(tready), .Y(tready_inv));
  \$_MUX_ u4 (.A(nt_prescale[9]), .B(prescale[12]), .S(N10),.Y(_N145));
  \$_XOR_ u5 (.A(bit_cnt[0]), .B(bit_cnt[1]), .Y(N324_inv));

                                    å›¾ 6 ç»„åˆé€»è¾‘é—¨ç¤ºä¾‹

  è¾“å‡ºæ–‡ä»¶å¿…é¡»æ˜¯ Verilog æ ¼å¼çš„ç»“æž„åŒ–ç½‘è¡¨ã€‚åŒæ ·ä¸åŒºåˆ†è¾“å‡ºæ–‡ä»¶æ˜¯å±žäºŽåŸºç¡€é¢˜

æˆ–è¿›é˜¶é¢˜ã€‚

å…«ã€è¯„åˆ†æ ‡å‡†
  ç”¨ä¾‹æˆç»©ç”±å¯æ‰§è¡Œç¨‹åºçš„æœ€ç»ˆè¾“å‡ºæ–‡ä»¶å†³å®šã€‚å‚èµ›è€…æ‰€æäº¤çš„å¯æ‰§è¡Œç¨‹åºçš„è¾“å‡º



                                                6
æ–‡ä»¶ï¼Œä¼šæŒ‰ç…§å¦‚ä¸‹å…¬å¼è®¡ç®—å…¶çš„ä»£ä»·å‡½æ•°ï¼Œcost æ•°å€¼è¶Šå°ä»£è¡¨ç»“æžœè´¨é‡è¶Šé«˜ï¼š
                 max logic level
      cost = (                   + 1) âˆ— num_of_luts âˆ— 10 + num_of_pins
                       20
  å…¶ä¸­max logic levelä¸ºè¾“å‡ºç»“æžœä¸­æœ€å¤§çš„ GTP_LUT å’Œ GTP_LUT6D çš„ä¸²è”çº§æ•°ï¼Œ

å³ä¿¡å·è¿žç»­ç»è¿‡ GTP_LUT æˆ– GTP_LUT6D çš„æœ€å¤§ä¸ªæ•°ï¼›num_of_lutsä¸ºè¾“å‡ºç»“æžœä¸­

GTP_LUT å’Œ GTP_LUT6D çš„æ€»æ•°é‡ï¼›num_of_pinsä¸ºè¾“å‡ºç»“æžœä¸­æ‰€æœ‰ GTP_LUT å’Œ

GTP_LUT6D çš„è¾“å…¥ç«¯å£çš„æ€»æ•°é‡ï¼Œæ— è®ºè¾“å…¥ç«¯å£æ˜¯å¦è¿žæŽ¥äº†ä¿¡å·ï¼Œæˆ–è€…è¿žæŽ¥çš„ä¿¡å·

æ˜¯å¦æ˜¯å¸¸é‡ã€‚

  ç”¨ä¾‹åˆ†æ•°(benckmark_score)æ˜¯æ‰€æœ‰ ratio çš„å‡ ä½•å¹³å‡æ•° x100ã€‚æ¯ä¸ªç”¨ä¾‹å¯¹åº”çš„ ratio

çš„è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š

       benckmark_score = geomean([ratio0 , ratio1, â€¦ , ration ]) âˆ— 100
                              (basei âˆ’ cost)
                     max (1 +                , 0.7), map_success
           ratioi = {             basei
                            0.6,             map_failed
  å…¶ä¸­baseiæ˜¯æ¯”è¾ƒåŸºå‡†å€¼ï¼Œæ˜¯ç”¨ä¾‹ i æ‰§è¡Œ synth_pango åŠŸèƒ½ï¼ˆèµ›å‰æä¾›çš„åŸºç¡€ä»£ç 

ä¸­çš„åŠŸèƒ½ï¼‰åŽè¾“å‡ºç½‘è¡¨çš„ costã€‚

  ä¸‹åˆ—æƒ…å†µä¼šè§†ä¸º map failed:

  ï¼ˆ1ï¼‰ è¾“å‡ºç»“æžœä¸­å­˜åœ¨æœªæ˜ å°„çš„ç»„åˆé€»è¾‘é—¨ï¼›

  ï¼ˆ2ï¼‰ è¾“å…¥ç”¨ä¾‹å’Œè¾“å‡ºç»“æžœçš„é€»è¾‘ä¸ä¸€è‡´ï¼›

  demo. ysæ–‡ä»¶ä¸­ç»™å‡ºäº†ä¸€ä¸ªç¤ºä¾‹ï¼Œåˆ©ç”¨ yosys å†…ç½®çš„ equiv åŠŸèƒ½æ¥éªŒè¯ä¸¤ä¸ªç½‘è¡¨çš„

é€»è¾‘ä¸€è‡´æ€§ã€‚

  ï¼ˆ3ï¼‰ è¾“å‡ºç»“æžœä¸­å­˜åœ¨ä¸æ”¯æŒçš„ cell ç±»åž‹ï¼›

  è¯·ç¡®ä¿æœ€åŽè¾“å‡ºç»“æžœä¸­çš„ Cell å‡ä¸º GTP ç±»åž‹ï¼Œ
                            ä¸”æ²¡æœ‰ä¿®æ”¹è¾“å…¥ç”¨ä¾‹ä¸­å­˜åœ¨çš„ GTP

cell åŠæ‰€è¿žä¿¡å·ã€‚

  ï¼ˆ4ï¼‰ è¾“å‡ºç»“æžœä¸­å­˜åœ¨ LUT size > 6 çš„ GTP_LUTï¼›




                                       7
    ç»„åˆé€»è¾‘é—¨åªå¯ä»¥æ˜ å°„åˆ° GTP_LUT1~GTP_LUT6ï¼ŒGTP_LUT6Dã€‚

    ï¼ˆ5ï¼‰ è¾“å‡ºç»“æžœä¸­å­˜åœ¨ç»„åˆé€»è¾‘çŽ¯è·¯ ï¼›

    ç”¨ä¾‹é»˜è®¤ä¸å«æœ‰ç»„åˆé€»è¾‘çŽ¯è·¯ï¼Œè¾“å‡ºç»“æžœä¸­ä¹Ÿä¸èƒ½å«æœ‰ç»„åˆé€»è¾‘çŽ¯è·¯ã€‚ç‰¹åˆ«æé†’

GTP_LUT6D çš„è¾“å‡ºç«¯å£ä¸èƒ½è¿žæŽ¥åˆ°è‡ªèº«çš„è¾“å…¥ç«¯å£ã€‚

    ï¼ˆ6ï¼‰ å ç”¨å†…å­˜è¶… 15GBï¼›

    ï¼ˆ7ï¼‰ è¶…è¿‡ 30 åˆ†é’Ÿæœªæ­£å¸¸ç»“æŸï¼›

    ï¼ˆ8ï¼‰ å¤šæ¬¡è¿è¡Œç¨‹åºå¹¶è¾“å…¥ç›¸åŒçš„ç”¨ä¾‹è¾“å‡ºç»“æžœä¸ä¸€è‡´ï¼›

    ï¼ˆ9ï¼‰ GTP_LUT6D çš„ Z5 å’Œ Z çš„é€»è¾‘æ²¡æœ‰å…±äº«çš„è¾“å…¥ï¼›

    ä¾‹å¦‚ Z=I0&I1ï¼ŒZ5=I2|I3ã€‚

    score. ccä»£ç ä¸­æ ¹æ®èµ›é¢˜çš„æè¿°ï¼Œå®žçŽ°äº† cost è®¡ç®—åŠŸèƒ½ï¼Œå¯ä»¥ä½¿ç”¨ score å‘½ä»¤è®¡ç®—

è¾“å‡ºæ–‡ä»¶çš„ costã€‚

    ç›¸åŒåˆ†æ•°çš„æƒ…å†µä¸‹ï¼Œï¼ˆ1ï¼‰æ¯”è¾ƒå¤±è´¥ç”¨ä¾‹æ•°é‡ï¼Œæ•°é‡æ›´å°‘çš„é˜Ÿä¼æŽ’åæ›´é«˜ï¼›ï¼ˆ2ï¼‰

æ¯”è¾ƒç”¨ä¾‹åˆ†æ•°benckmark_scoreï¼Œåˆ†æ•°è¶Šé«˜æŽ’åè¶Šé«˜ã€‚

ä¹ã€å‚è€ƒæ–‡çŒ®

    [1] Manohararajah V , Brown S D , Vranesic Z G .Heuristics for Area Minimi

zation in LUT-Based FPGA Technology Mapping[J].IEEE Transactions on Computer-

Aided Design of Integrated Circuits and Systems, 2006, 25(11):2331-2340.DOI:10.a11

09/TCAD.2006.882119.

    [2]Yosys,https://yosyshq.readthedocs.io/projects/yosys/en/latest/index.html.

    [3] Scholl C .Functional decomposition with application to FPGA synthesis /[J].

IEEE Circuits and Devices Magazine, 2001.DOI:10.1109/MCD.2003.1263462.

    [4] Kubica Marcin , Opara Adam , Kania Dariusz .Technology Mapping for L




                                            8
UT-Based FPGA[M]. 2021.

    [5] Feng Wang, Liren Zhu, Jiaxi Zhang, Lei Li, Yang Zhang, Guojie Luo, "Du

al-Output LUT Merging during FPGA Technology Mapping," Proceedings of the Inte

rnational Conference on Computer-Aided Design (ICCAD 2020), Virtual Conference,

 November 2-5, 2020.

    [6] Lu Sheng, Shang Liuting, Qu Qian, Jung Sunyong, Liang Qilian, Pan Chen

yun. An Efficient Multi-Output LUT Mapping Technique for Field-Programmable Ga

te Arrays[J].Electronics (2079-9292), 2025, 14(9).DOI:10.3390/electronics14091782.

    [7] Liwei Ni, Zonglin Yang, Jiaxi Zhang, Changhong Feng, Jianhua Liu, Guojie

 Luo, Huawei Li, Biwei Xie, Xingquan Li, "MEC: An Open-source Fine-grained M

apping Equivalence Checking Tool for FPGA," Proceedings of the International Sym

posium of EDA (ISEDA 2023), Nanjing, China, pp. 131-136, May 8-11, 2023.



*æœ¬èµ›é¢˜æŒ‡å—æœªå°½é—®é¢˜ï¼Œè§èµ›é¢˜ Q&A æ–‡ä»¶




                                          9
              2025 China Postgraduate IC Innovation
           CompetitionÂ·EDA Elite Challenge Contest


1. Problem
Logic Mapping Algorithm for FPGA Dual Output LUTs

2. Company
Shenzhen Pango Microsystems Co., Ltd.

3. Problem Background

Current advanced FPGA (Field Programmable Gate Array) architectures usually use

dual-output LUT (Look-Up-Table) structures (hereinafter referred to as â€œdual-output

LUTsâ€). The traditional LUT mapping algorithm can only map combinational logic gates to

a single output LUT, which brings a new challenge to FPGA synthesis tools, â€œhow to better

map combinational logic to dual output LUTsâ€. The two output ports of a dual-output LUT

share part of the input, and the two outputs need to satisfy a certain logical relationship

between them. The difficulty lies in how to utilize the structure of the dual-output LUT

during the mapping process and reflect the impact of the dual-output LUT in the cost

function, as well as how to combine the LUTs to minimize the total area of the netlist at the

end of the mapping process.

The FPGA design flow is shown in Figure 1. This contest problem belongs to the FPGA

logic synthesis category in EDA (Electronic Design Automation) technology. The problem

is divided into two parts: basic problem and advanced problem. The basic question is, given

a mapped single-port LUT netlist, to find an algorithm to combine two LUTs into a




                                             10
dual-output LUT, so that the final number of LUTs in the netlist is as small as possible; the

advanced question is how to modify the traditional single-port LUT mapping algorithm to

map directly to a dual-output LUT to realize the minimum number of LUTs. The two

questions belong to the Technology-dependent Optimization (which refers to the optimize

netlist using specific technology libraries) and Technology Map (which refers to the

mapping of generic circuit cells to cells in specific technology libraries) parts of logic

synthesis.




                             Figure 1 EDA design flow for FPGAs

4. Demo Flow
PANGO has provided a base code. The base code is written based on the open source

project YOSYS. Participants can make modifications on the basis of this code. Figure 2

shows a demo flow using this code.

The scripts and test cases provided by PANGO are stored at yosys/techlibs/pango.

synth_pango. cc implemented a mapping algorithm based on reference [1], the function is




                                             11
to map the combinational logic gates in the netlist to the LUT primitive of PANGO, with

some conjectures and simplifications on the details not mentioned in the literature, which

can be used with the synth_pango command under the yosys tool. The function of

score. cc is to compute the cost function of the mapped netlist, which can be used by score

command under the yosys tool.




                               Figure 2 demo flow using base code

Yosys project contains two important data structures, SigBit and Cell.

SigBit is one bit of wire in yosys. Logic synthesis is not concerned with the bit width of the

wires and the assign relationship between the wires, so the interconnected wires are

converted to the unique SigBit representation. Base code uses SigBit object to get its

driver, reader, depth and other data.

The synthesis process only focuses on the cell of combinational logic gates, the cases

provided by PANGO only include the combinational logic gates of AND, OR, XOR,

Multiplexer, Inverter. Other types of cells must be preserved as is without any processing.

5. Dual Output LUT Architecture
The cell types starting with GTP_ are FPGA primitives of PANGO. yosys/techlibs/

pango/pango_sim. v file contains the simulation models of some primitives.


                                              12
GTP_LUT1~GTP_LUT6 are n-input and 1-output lookup tables.

GTP_LUT6D is a 6-input, 2-output lookup table whose simulation model is shown in

Figure 3 and internal structure in Figure 4.

In the estimation of resource consumption, GTP_LUT6D and GTP_LUT are equal, both of

them will occupy one lookup table hardware resource in the FPGA chip, but GTP_LUT6D

can additionally realize one 5-input and 1-output lookup table in addition to the function of

GTP_LUT6, and the logic expression of Z5 is a sub-expression of the Z logic expression,

and the I[4:0] of two logic expressions are the same. Therefore, we could combine two

logic expressions with the same or similar inputs together using a single GTP_LUT6D to

reduce area.




                                               13
  // GTP_LUT6D ä»¿çœŸæ¨¡åž‹
  module GTP_LUT6D
  #(
       parameter [63:0] INIT = 64'h0000_0000_0000_0000
  )(
       output Z,
       output Z5,
       input I0,
       input I1,
       input I2,
       input I3,
       input I4,
       input I5
  );
  wire z5a,z5b;
  $lut #(.WIDTH(5),.LUT(INIT[31:0])) luta_cell(.A({I4,I3,I2,I1,I0}),.Y(z5a));
  $lut #(.WIDTH(5),.LUT(INIT[63:32])) lutb_cell(.A({I4,I3,I2,I1,I0}),.Y(z5b));
  $mux #(.WIDTH(1)) u1(.A(z5a),.B(z5b),.S(I5),.Y(Z));
  assign Z5 = z5a;
  endmodule


                               Figure 3 GTP_LUT6D simulation model




                             Figure 4 Internal structure of GTP_LUT6D

6. Competition Description



                                                  14
The competition content consists of two questions:

(1) Basic questions

Given a mapped single-port GTP_LUT netlist, design algorithms to combine the

GTP_LUTs in the netlist into GTP_LUT6Ds, minimizing the total number of GTP_LUTs

and GTP_LUT6Ds. For example, if there are two GTP_LUTs in the netlist whose logic is

O1 = A&B&D&E and O2 = A&B&C&F | A&B&D&E respectively, the two GTP_LUTs can

be combine to become one GTP_LUT6D, and the total number of LUTs in the netlist is

reduced by 1 after combing.




                                Figure 5 combine LUT Example

(2) Advanced Questions

Design algorithms to direct mapping combinational logic gate to GTP_LUT6D. Participants

can modify or redesign the mapping algorithm to realize direct mapping out of

GTP_LUT6D using the least number of total LUTs.

Participants must submit an executable program, along with the necessary documentation.

It is recommended to submit the source code in case the submitted program fail to run on

test server due to lib dependency issue.


                                             15
7. Benchmarks
At least 6 development test cases and at least 10 evaluation test cases will be provided by

PANGO. Development test cases will be published before the competition, while evaluation

test cases will not be made public until the end of the competition. There is variance in

scale among these test cases, with no distinction in difficulty.

The cases for the basic and advanced questions are the same and are not differentiated. If

participant choose to solve only the basic question, also needed map the combinational

logic gate to a GTP_LUT, either using the synth_pango function in the base code or

otherwise.

The non-combinatorial logic of these cases has already been mapped to the GTP type of the

PANGO, and participant only need to deal with the remaining combinatorial logic gates; an

example of the five combinatorial logic gates that need to be dealt with is given in Figure 6.

All cases are characterized as follows:

(1) File is structured Verilog format, without procedure blocks or high-level operators;

(2) Include only one flattened module, and only included yosys built-in cell types or GTP

cell types;

(3) non-combinational logic gates (registers, RAM, IO, etc.) are considered to be black

boxes, and participants cannot make any modifications to them;

(4) The combinational logic gate types are all yosys built-in logic gate types, and only the

five types in Figure 6 exist; $_AND_, $_OR_, and $_XOR_ are all 2-input logic gates, and

$_MUX_ and $_NOT_ have a bit width of one.




                                               16
     \$_OR_    u1 (.A(nt_rst), .B(N145 ), .Y(N145_1 ));
     \$_AND_ u2 (.A(N6_inv), .B(N167_4 ), .Y(N107 ));
     \$_NOT_ u3 (.A(tready), .Y(tready_inv));
     \$_MUX_ u4 (.A(nt_prescale[9]), .B(prescale[12]), .S(N10),.Y(_N145));
     \$_XOR_ u5 (.A(bit_cnt[0]), .B(bit_cnt[1]), .Y(N324_inv));

                                  Figure 6 combinational gate types




The output file must be structured Verilog. No distinction is made as to whether the output

file belongs to a basic or advanced question.

8. Scoring Criteria
Score is determined by the final output file of the executable program. The output file of the

executable program submitted by the participant is calculated as a cost function according

to the following formula, where the smaller the cost value is, the higher the quality of the

result:
                      max logic level
           cost = (                   + 1) âˆ— num_of_luts âˆ— 10 + num_of_pins
                            20
Where max logic level is the maximum number of GTP_LUTs and GTP_LUT6Ds in

series in the output file, i.e., the maximum number of the signal through a GTP_LUT or

GTP_LUT6D; num_of_luts is the total number of GTP_LUTs and GTP_LUT6Ds in the

output result; num_of_pins is the total number of input ports of all the GTP_LUTs and

GTP_LUT6Ds in the output file, whether the input ports are connected to signals or not, or

whether the connected signals are constants or not.

The score is the geometric mean of all the ratio âˆ— 100. The formula for the corresponding

ratio of each case is as follows:

              benckmark_score = geomean([ratio0 , ratio1, â€¦ , ration ]) âˆ— 100



                                                  17
                                   (basei âˆ’ cost)
                             max (1 +             , 0.7), ð‘šð‘Žð‘_ð‘ ð‘¢ð‘ð‘ð‘’ð‘ ð‘ 
                ratioi = {             basei
                                 0.6,            ð‘šð‘Žð‘_ð‘“ð‘Žð‘–ð‘™ð‘’ð‘‘
Here basei is the comparative benchmark value, which is the cost of the output netlist

after use the synth_pango function (the function in the base code) with input casei .

Output result will be treated as map failure, if:

(1) there are unmapped combinational logic gates in the output results;

(2) there is logic mismatch between input file and output results;

An example is given in demo. ys, using the built-in equiv function of yosys to verify the

logical equivalence of two netlists.

(3) unsupported cell types are present in the output results;

Make sure that the cells in the final output result are all of GTP type, and the signals

connect to GTP cells present in the input have not been modified.

(4) exists GTP_LUT with LUT size > 6;

The combinational logic gates can be mapped only to GTP_LUT1 to GTP_LUT6 and

GTP_LUT6D.

(5) Combinatorial logic loops are present in the output ;

The cases do not contain combinational logic loops by default and cannot contain

combinational logic loops in the output result. Note that the output port of GTP_LUT6D

cannot connect to its own input port.

(6) Occupying more than 15 GB of memory;

(7) Not ending normally more than 30 minutes;

(8) Multiple runs of the program with the same input produce different output results;

(9) The logic of Z5 and Z of GTP_LUT6D does not share any input;




                                               18
For example Z=I0&I1, Z5=I2|I3.

score. cc implement the cost calculation function according to the description before, and

you can use the score command to calculate the cost of the output file.

For the same score, (1) compare the number of failed use cases, the team with less number

is ranked higher; (2) compare benckmark_score, the higher the score the higher the

ranking.

9. References
[1] Manohararajah V , Brown S D , Vranesic Z G .Heuristics for Area Minimizatio

n in LUT-Based FPGA Technology Mapping[J].IEEE Transactions on Computer-Aide

d Design of Integrated Circuits and Systems, 2006, 25(11):2331-2340.DOI:10.a1109/T

CAD.2006.882119.

[2] Yosys,https://yosyshq.readthedocs.io/projects/yosys/en/latest/index.html.

[3] Scholl C .Functional decomposition with application to FPGA synthesis /[J].IEEE

Circuits and Devices Magazine, 2001.DOI:10.1109/MCD.2003.1263462.

[4] Kubica Marcin , Opara Adam , Kania Dariusz .Technology Mapping for LUT-Based

FPGA[M]. 2021.

[5] Feng Wang, Liren Zhu, Jiaxi Zhang, Lei Li, Yang Zhang, Guojie Luo, "Dual-Output

LUT Merging during FPGA Technology Mapping," Proceedings of the International

Conference on Computer-Aided Design (ICCAD 2020), Virtual Conference, November 2-5,

2020.

[6] Lu Sheng, Shang Liuting, Qu Qian, Jung Sunyong, Liang Qilian, Pan Chenyun. An

Efficient Multi-Output     LUT Mapping        Technique for     Field-Programmable Gate




                                             19
Arrays[J].Electronics (2079-9292), 2025, 14(9).DOI:10.3390/electronics14091782.

[7] Liwei Ni, Zonglin Yang, Jiaxi Zhang, Changhong Feng, Jianhua Liu, Guojie Luo,

Huawei Li, Biwei Xie, Xingquan Li, "MEC: An Open-source Fine-grained Mapping

Equivalence Checking Tool for FPGA," Proceedings of the International Symposium of

EDA (ISEDA 2023), Nanjing, China, pp. 131-136, May 8-11, 2023.



* For questions not covered in this guide, please refer to the Q&A document.




                                            20
